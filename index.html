<!DOCTYPE html>

<head>
    <title>Our awesome game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>

<body>
    <h1>Our awesome game</h1>
    <h2>this is just a H2</h2>

    <script>

        let cursors
        let knight
        let crates
        let coins
        let coinTimer
        
        let score = 0
        let scoreText

        let secondsLeft = 60
        let timeLeftText
        let timeLeftTimer

        let gameOver = false

        const characterParameters = {
            horizontalVelocity: 350,
            jumpForce: -600,
        }

        // configure the game
        const config = {
            width: 800,
            height: 500,
            type: Phaser.AUTO,
            scene: {
                preload: gamePreload,
                create: gameCreate,
                update: gameUpdate,
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 900 },
                    debug: false,
                },
            },
        }

        const game = new Phaser.Game(config)

        // loading assets
        function gamePreload() {
            this.load.image('knight', 'assets/knight.png')
            this.load.image('crate', 'assets/crate.png')
            this.load.image('background', 'assets/background.png')

            // load knight
            for (i = 1; i <= 10; i++) {
                this.load.image(`run_frame_${i}`, `assets/knight/run/Run (${i}).png`)
            }

            // load knight
            for (i = 1; i <= 10; i++) {
                this.load.image(`idle_frame_${i}`, `assets/knight/idle/Idle (${i}).png`)
            }

            this.load.image('bitcoin', 'assets/bitcoin.png')
        }

        // initial setup logic on the asset and other setup
        function gameCreate() {
            this.add.image(300, 150, 'background')

            knight = this.physics.add.sprite(400, 0, 'knight')
            knight.body.setSize(200, 600, 10, 0)
            knight.scale = 0.15

            crates = this.physics.add.staticGroup()

            // floor
            crates.create(40, 460, 'crate')
            crates.create(120, 460, 'crate')
            crates.create(200, 460, 'crate')
            crates.create(280, 460, 'crate')
            crates.create(360, 460, 'crate')
            crates.create(440, 460, 'crate')
            crates.create(740, 420, 'crate')
            crates.create(650, 360, 'crate')

            // crates in the air
            crates.create(440, 360, 'crate')
            crates.create(480, 260, 'crate')
            crates.create(480, 260, 'crate')
            crates.create(280, 260, 'crate')
            crates.create(180, 220, 'crate')

            // xpto
            crates.create(620, 170, 'crate')

            // create animation
            this.anims.create({
                key: 'knight_run',
                frames: [
                    { key: 'run_frame_1' },
                    { key: 'run_frame_2' },
                    { key: 'run_frame_3' },
                    { key: 'run_frame_4' },
                    { key: 'run_frame_5' },
                    { key: 'run_frame_6' },
                    { key: 'run_frame_7' },
                    { key: 'run_frame_8' },
                    { key: 'run_frame_9' },
                    { key: 'run_frame_10' },
                ],
                frameRate: 10,
                repeat: 1,
            })

            this.anims.create({
                key: 'knight_idle',
                frames: [
                    { key: 'idle_frame_1' },
                    { key: 'idle_frame_2' },
                    { key: 'idle_frame_3' },
                    { key: 'idle_frame_4' },
                    { key: 'idle_frame_5' },
                    { key: 'idle_frame_6' },
                    { key: 'idle_frame_7' },
                    { key: 'idle_frame_8' },
                    { key: 'idle_frame_9' },
                    { key: 'idle_frame_10' },
                ],
                frameRate: 10,
                repeat: 1,
            })

            this.physics.add.collider(crates, knight)

            cursors = this.input.keyboard.createCursorKeys()

            coinTimer = this.time.addEvent({
                delay: Phaser.Math.Between(0, 5000),
                callback: generateCoins,
                callbackScope: this,
                repeat: -1,
            })

            timeLeftTimer = this.time.addEvent({
                delay: 1000,
                callback: updateTimeLeft,
                callbackScope: this,
                repeat: -1,
            })

            scoreText = this.add.text(16, 16, 'Bitcoin bag: 0', {
                fontSize: '32px',
                fill: '#000',
            })

            timeLeftText = this.add.text(16, 46, secondsLeft.toString() + ' seconds left', {
                fontSize: '32px',
                fill: '#f00',
            })
        }

        function updateTimeLeft() {

            if (gameOver) return

            secondsLeft--

            // "Guard return terminate game"
            if (secondsLeft <= 0) {
                this.physics.pause()
                gameOver = true
            }

            timeLeftText.setText(secondsLeft.toString() + ' seconds left')
        }

        function generateCoins() {
            coins = this.physics.add.group({
                key: 'bitcoin',
                repeat: 1,
                setXY: {
                    x: Phaser.Math.Between(0, 800),
                    y: -100,
                    stepX: Phaser.Math.Between(30, 100),
                },
            })

            coins.children.iterate(child => {
                child.setBounceY(Phaser.Math.FloatBetween(0.2, 0.6))
            })

            this.physics.add.collider(coins, crates)
            this.physics.add.overlap(knight, coins, collectCoin, null, this)
        }

        function collectCoin(knight, coin) {
            coin.disableBody(true, true)
            score++

            scoreText.setText('Bitcoin bag: ' + score.toString())
        }

        // monitoring inputs and telling game how to update
        function gameUpdate() {
            if (cursors.left.isDown) {
                knight.setVelocityX(characterParameters.horizontalVelocity * -1)
                knight.play('knight_run', true)
                knight.flipX = true
            }

            else if (cursors.right.isDown) {
                knight.setVelocityX(characterParameters.horizontalVelocity)
                knight.play('knight_run', true)
                knight.flipX = false
            }

            else {
                knight.setVelocityX(0)
                knight.play('knight_idle', true)
            }

            if (cursors.space.isDown && knight.body.touching.down) {
                knight.setVelocityY(characterParameters.jumpForce)
            }
        }
    </script>

</body>

</html>